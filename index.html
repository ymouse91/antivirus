<!doctype html>
<html lang="fi">
<head>
  <meta charset="utf-8" />

  <!-- iOS: viewport-fit=cover on pakko safe-areaa varten -->
  <meta name="viewport"
        content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover">

  <!-- PWA perus -->
  <link rel="manifest" href="manifest.webmanifest">
  <meta name="theme-color" content="#0b1533"> <!-- Android/Chrome -->
  <meta name="color-scheme" content="dark light">

  <!-- iOS PWA -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Peli">

  <!-- Icons -->
  <link rel="icon" href="icon192.png">
  <link rel="apple-touch-icon" href="icon192.png">

  <style>
    :root{
      --bg: #0b1533;
      --ink: #eaf0ff;

      /* JS asettaa --vh */
      --vh: 1vh;

      /* safe area */
      --sat: env(safe-area-inset-top);
      --sar: env(safe-area-inset-right);
      --sab: env(safe-area-inset-bottom);
      --sal: env(safe-area-inset-left);

      /* game sizing */
      --cell: 56px;
      --gap: 8px;
      --boardPad: 10px;

      /* dots */
      --dotScale: 1.30;
      --dotBorder: 2px;

      --good: #49e2a8;
      --bad:  #ff5a6a;
      --warn: #ffd35a;
    }

    /* TÄRKEÄ: html-tausta estää valkoiset “nauhat” kuminauhassa */
    html{
      height: 100%;
      background: var(--bg);
      background-color: var(--bg);
    }

    body{
      margin:0;
      height: 100%;
      min-height: calc(var(--vh) * 100);
      background: var(--bg);
      color: var(--ink);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background:linear-gradient(135deg,#0f172a 0%,#1a2a4a 50%,#0f172a 100%);
      overflow: hidden;
      overscroll-behavior: none;

      -webkit-text-size-adjust: 100%;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }

    /* App-container hoitaa safe-areat (ei body!) */
    #app{
      position: fixed;
      inset: 0;
      padding: max(12px, var(--sat)) max(12px, var(--sar)) max(12px, var(--sab)) max(12px, var(--sal));
      display: grid;
      grid-template-rows: auto 1fr auto;
      gap: 10px;
      background: radial-gradient(1200px 800px at 30% 10%, #162a67 0%, var(--bg) 55%, #070c1d 100%);
    }

    header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      min-width:0;
    }

    .title{
      display:flex;
      gap:10px;
      align-items:baseline;
      min-width:0;
    }
    .title h1{ margin:0; font-size:22px; white-space:nowrap; }
    .title .sub{ font-size:12px; opacity:.85; font-weight:900; }

    .controls{
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
      justify-content:flex-end;
    }

    button, select{ font: inherit; color: var(--ink); }

    button{
      background: rgba(255,255,255,.10);
      border: 1px solid rgba(255,255,255,.20);
      border-radius: 10px;
      padding: 8px 10px;
      font-weight: 900;
      cursor:pointer;
      user-select:none;
    }
    button:active{ transform: translateY(1px); }
    button:disabled{ opacity:.45; cursor:default; transform:none; }

    select{
      background: rgba(0,0,0,.18);
      border: 1px solid rgba(255,255,255,.18);
      border-radius: 10px;
      padding: 8px 10px;
      font-weight: 900;
      outline:none;
      min-width: 240px;
      max-width: min(56vw, 420px);
    }

    main{
      min-height: 0;
      display:flex;
      align-items:center;
      justify-content:center;
    }

    #game{
      width:100%;
      height:100%;
      display:flex;
      align-items:center;
      justify-content:center;
    }

    #board{
      position: relative;
      width: calc(var(--cell) * 8 + var(--gap) * 7 + var(--boardPad) * 2);
      height: calc(var(--cell) * 8 + var(--gap) * 7 + var(--boardPad) * 2);
      border-radius: 18px;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.14);
      box-shadow: 0 18px 40px rgba(0,0,0,.28);
      padding: var(--boardPad);
      touch-action: none;
      user-select:none;
    }

    #exitTag{
      position:absolute;
      /* EXIT on ruudulla A1 (0,0) */
      left: var(--boardPad);
      top: var(--boardPad);
      width: var(--cell);
      height: var(--cell);
      /* Keskitä teksti flex-boxilla */
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      font-weight: 1000;
      opacity:.9;
      border-radius: 999px;
      background: rgba(73,226,168,.15);
      border: 1px solid rgba(73,226,168,.35);
      pointer-events:none;
      text-align: center;
    }

    #grid{
      position:absolute;
      inset: var(--boardPad);
      display:grid;
      grid-template-columns: repeat(8, var(--cell));
      grid-template-rows: repeat(8, var(--cell));
      gap: var(--gap);
    }

    .cell{
      border-radius: 999px;
      background: rgba(0,0,0,.22);
      border: 1px solid rgba(255,255,255,.06);
      opacity:.55;
      position:relative;
    }
    .cell.playable{
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.22);
      opacity: 1;
      cursor:pointer;
    }
    .cell.off{
      background: rgba(0,0,0,.34);
      border: 1px solid rgba(255,255,255,.05);
      opacity: .45;
    }
    .cell.exit{
      outline: 7px solid rgba(73,226,168,.45);
      outline-offset: -1px;
    }

    .hint{
      position:absolute;
      inset: 18%;
      border-radius: 999px;
      border: 3px solid rgba(255,255,255,.78);
      box-shadow: 0 0 0 2px rgba(0,0,0,.18) inset;
      pointer-events:none;
      opacity:.95;
    }

    .dot{
      position:absolute;
      width: calc(var(--cell) * var(--dotScale));
      height: calc(var(--cell) * var(--dotScale));
      border-radius: 999px;
      box-sizing:border-box;
      border: var(--dotBorder) solid rgba(255,255,255,.35);
      box-shadow: 0 10px 20px rgba(0,0,0,.25);
    }
    .pieceDot{ cursor:pointer; }
    .pieceDot.selected{
      outline: 3px solid rgba(255,255,255,.90);
      outline-offset: 2px;
    }
.pieceDot.grouped{
  outline: 3px solid rgba(255,255,255,.90);
  outline-offset: 2px;
}

    .pieceDot.dragging{
      opacity: 0.8;
      filter: drop-shadow(0 0 8px rgba(255,255,255,0.3));
    }
    .blockDot{
      border: var(--dotBorder) solid rgba(0,0,0,.18);
      background: rgba(255,255,255,.92);
      cursor: default;
      pointer-events:none;
    }

    footer{ text-align:center; opacity:.95; font-weight:900; }
    footer.ok{ color: var(--good); }
    footer.bad{ color: var(--bad); }
    footer.warn{ color: var(--warn); }

    /* iPhone portrait: tilaa pienemmäksi, fontteja alas */
    @media (max-width: 430px) and (orientation: portrait) and (hover:none) and (pointer:coarse){
      #app{ gap: 8px; padding: max(10px, var(--sat)) 10px max(10px, var(--sab)); }
      .title h1{ font-size: 20px; }
      select{ min-width: 100px; padding: 7px 9px; }
      button{ padding: 7px 9px; }
	  /* Estä iOS:n 100vw + safe-area -leikkaus */
#game{
  width: 100%;
  max-width: 100%
  box-sizing: border-box;
  overflow: hidden;
}

/* Board ei saa koskaan ylittää parenttia */
#board{
  max-width: 100%;
  box-sizing: border-box;
}
@media (max-width: 430px) and (orientation: portrait) and (hover:none) and (pointer:coarse){

  /* Header kahteen riviin */
  header{
    flex-direction: column;
    align-items: stretch;
    gap: 6px;
  }

  /* Ylärivi: pelin nimi */
  .title{
    justify-content: center;
  }

  .title h1{
    font-size: 18px;
    text-align: center;
  }

  /* Alarivi: kontrollit */
  .controls{
    justify-content: space-between;
    flex-wrap: nowrap;
    gap: 6px;
  }

  /* Pulmavalitsin kevyemmäksi */
  #puzzleSelect{
    min-width: 0;
    max-width: 46vw;
    font-size: 13px;
    padding: 6px 8px;
    font-weight: 700;
  }

  /* Edellinen / seuraava pienemmiksi */
  #btnPrev,
  #btnNext{
    padding: 6px 8px;
    font-size: 14px;
  }

  /* Reset & Ohjeet toissijaisiksi */
  #btnReset,
  #btnHelp{
    padding: 6px 8px;
    font-size: 12px;
    font-weight: 700;
    opacity: 0.85;
  }
}

    }
  </style>
</head>

<body>
  <div id="app">
    <header>
      <div class="title">
        <h1>Anti-Virus</h1>
        <div class="sub" style="display:none">mekaniikkatesti</div>
      </div>

      <div class="controls">
        <button id="btnPrev" title="Edellinen pulma" style="display:none">◀</button>
        <select id="puzzleSelect" aria-label="Valitse pulma"></select>
        <button id="btnNext" title="Seuraava pulma">▶</button>

        <button id="btnReset">Reset</button>
        <button id="btnExample" style="display:none">Esimerkki</button>
        <button id="btnHelp">Ohjeet</button>
      </div>
    </header>

    <main>
      <div id="game"></div>
    </main>

    <footer id="status" class="warn">Ladataan…</footer>
  </div>

  <script>
    // iOS viewport-korkeus oikein (estää valkoisia nauhoja ja “kuminauhaa”)
    function setVH(){
      document.documentElement.style.setProperty("--vh", (window.innerHeight * 0.01) + "px");
    }
    setVH();
    window.addEventListener("resize", setVH);

    // iOS: estä “double tap zoom” (usein peleissä toivottu)
    let lastTouchEnd = 0;
    document.addEventListener("touchend", (e) => {
      const now = Date.now();
      if (now - lastTouchEnd < 300) e.preventDefault();
      lastTouchEnd = now;
    }, { passive:false });
  </script>

  <script>
    // SW rekisteröinti (PWA/offline)
    if ("serviceWorker" in navigator){
      navigator.serviceWorker.register("./sw.js", { scope: "./" }).catch(()=>{});
    }
  </script>

  <script>
    /* =========================
       Anti-Virus: puzzles + test-mekaniikka
       ========================= */

    const PUZZLES_URL = "antivirus-puzzles.json";
    const LS_KEY = "antivirus_play_v1";

    /* --- board rules --- */
    const W=8, H=8;
    function onBoard(x,y){ return x>=0 && x<W && y>=0 && y<H; }
    function isWhite(x,y){ return ((x+y)&1)===0; } // A1 (0,0) valkea

    // Käytössä vain valkeat B–H ja 2–8, plus EXIT A1.
    function isPlayable(x,y){
      if (!onBoard(x,y)) return false;
      if (x===0 && y===0) return true; // EXIT
      if (y===0) return false;         // rivi 1 pois
      if (x===0) return false;         // sarake A pois
      return isWhite(x,y);
    }
    function key(x,y){ return `${x},${y}`; }

    /* --- piece defs (lukittu, kuten sovittu) --- */
    const PIECE_DEFS = {
      0: { id:0, name:"Punainen",     color:"#ff3b3b", shape:[[0,0],[1,1]] },
      1: { id:1, name:"Vaaleansin.",  color:"#4ecbff", shape:[[0,0],[1,1]] },
      2: { id:2, name:"Oranssi",      color:"#ff9f1c", shape:[[0,0],[1,1],[0,2]] },
      3: { id:3, name:"Pinkki",       color:"#ff7abf", shape:[[0,0],[0,2]] },
      4: { id:4, name:"Tummanvihreä", color:"#2ecc71", shape:[[0,0],[0,2]] },
      5: { id:5, name:"Tummansininen",color:"#1f5fbf", shape:[[0,0],[2,0],[4,0]] },
      6: { id:6, name:"Violetti",     color:"#b06cff", shape:[[0,0],[2,0],[2,2]] },
      7: { id:7, name:"Lime",         color:"#b7e600", shape:[[0,0],[1,1],[1,3]] },
      8: { id:8, name:"Keltainen",    color:"#ffd400", shape:[[0,0],[-1,1],[-1,3]] },
    };

    /* --- rotation: 90° CCW steps, no normalization on board --- */
    function rotPtCCW(dx, dy, steps){
      const r = ((steps%4)+4)%4;
      if (r===0) return [dx, dy];
      if (r===1) return [-dy, dx];
      if (r===2) return [-dx, -dy];
      return [dy, -dx]; // r===3
    }
    function rotatedPointsNoNorm(points, rotSteps){
      return points.map(([dx,dy]) => rotPtCCW(dx,dy,rotSteps));
    }
    function pieceCells(piece){
      const def = PIECE_DEFS[piece.id];
      const pts = rotatedPointsNoNorm(def.shape, piece.rot|0);
      return pts.map(([dx,dy]) => ({ x: piece.x0 + dx, y: piece.y0 + dy }));
    }

    /* --- UI refs --- */
    const elGame = document.getElementById("game");
    const elStatus = document.getElementById("status");
    const elPuzzleSelect = document.getElementById("puzzleSelect");
    const btnPrev = document.getElementById("btnPrev");
    const btnNext = document.getElementById("btnNext");
    const btnReset = document.getElementById("btnReset");
    const btnExample = document.getElementById("btnExample");
    const btnHelp = document.getElementById("btnHelp");

    function setStatus(msg, cls="warn"){
      elStatus.textContent = msg || "";
      elStatus.className = cls;
    }

    /* --- mount board --- */
    function mountBoard(){
      elGame.innerHTML = `
        <div id="board">
          <svg id="diagonalsLayer" style="position:absolute; inset:0; pointer-events:none; width:100%; height:100%;">
            <g id="diagonals"></g>
          </svg>
          <svg id="piecesConnectionLayer" style="position:absolute; inset:0; pointer-events:none; width:100%; height:100%;">
            <g id="piecesConnections"></g>
          </svg>
          <div id="exitTag">EXIT</div>
          <div id="grid"></div>
          <div id="hintsLayer"></div>
          <div id="blocksLayer"></div>
          <div id="piecesLayer"></div>
        </div>
      `;
      drawDiagonals();
    }

    function drawDiagonals(){
      const svg = document.getElementById("diagonals");
      svg.innerHTML = "";
      
      const cell = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--cell"));
      const gap = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--gap"));
      const pad = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--boardPad"));
      
      // Diagonaalit neljään suuntaan
      for (let i = 0; i < 8; i++){
        for (let j = 0; j < 8; j++){
          // Näytä vain ruudot joissa on validi peli
          if (!isPlayable(i,j)) continue;
          
          // Käytä ruudukon solun keskipistettä (ilman nappuloiden offsetia)
          const centerX = pad + i*(cell+gap) + cell/2;
          const centerY = pad + j*(cell+gap) + cell/2;
          
          // Neljä diagonaalia: yläoikea, alaoikea, alavasen, ylävasen
          const dirs = [
            {dx: 1, dy: -1},  // yläoikea
            {dx: 1, dy: 1},   // alaoikea
            {dx: -1, dy: 1},  // alavasen
            {dx: -1, dy: -1}  // ylävasen
          ];
          
          for (const dir of dirs){
            // Piirretään viiva seuraavaan ruutuun
            const nextI = i + dir.dx;
            const nextJ = j + dir.dy;
            
            if (nextI >= 0 && nextI < 8 && nextJ >= 0 && nextJ < 8 && isPlayable(nextI, nextJ)){
              const nextCenterX = pad + nextI*(cell+gap) + cell/2;
              const nextCenterY = pad + nextJ*(cell+gap) + cell/2;
              
              // Piirretään viiva
              const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
              line.setAttribute("x1", centerX);
              line.setAttribute("y1", centerY);
              line.setAttribute("x2", nextCenterX);
              line.setAttribute("y2", nextCenterY);
              line.setAttribute("stroke", "rgba(255,255,255,0.15)");
              line.setAttribute("stroke-width", "1.5");
              line.setAttribute("stroke-dasharray", "3,2");
              svg.appendChild(line);
            }
          }
        }
      }
    }

/* --- responsive cell size --- */
function rebuildCellSize(){
  // Kiinteät arvot (pidetään samana)
  const gap = 8;
  const pad = 10;

  const appEl = document.getElementById("app");
  if (!appEl) return;

  // 1) Mitataan #app:n oikea sisätila (safe-area on paddingissa)
  const cs = getComputedStyle(appEl);
  const padL = parseFloat(cs.paddingLeft)  || 0;
  const padR = parseFloat(cs.paddingRight) || 0;
  const padT = parseFloat(cs.paddingTop)   || 0;
  const padB = parseFloat(cs.paddingBottom)|| 0;

  let availW = Math.floor(appEl.clientWidth  - padL - padR);
  let availH = Math.floor(appEl.clientHeight - padT - padB);

  // 2) iPhone portrait: vähennä header+footer (+ #app gapit) samoin kuin ennen
  const isIphonePortrait = window.matchMedia(
    "(max-width: 430px) and (orientation: portrait) and (hover:none) and (pointer:coarse)"
  ).matches;

  if (isIphonePortrait){
    const headerEl = document.querySelector("#app > header");
    const footerEl = document.querySelector("#app > footer");
    const headerH = headerEl ? headerEl.getBoundingClientRect().height : 0;
    const footerH = footerEl ? footerEl.getBoundingClientRect().height : 0;

    const gridGap = parseFloat(cs.gap) || 10;
    const extra = 6;

    availH = Math.max(0, availH - headerH - footerH - (gridGap * 2) - extra);
  }

  // 3) iOS PWA (standalone): pieni pyöristys-/viewport-heitto -> turvavara
  const isStandalone =
    (window.matchMedia && window.matchMedia("(display-mode: standalone)").matches) ||
    (window.navigator && window.navigator.standalone);

  if (isStandalone){
    availW = Math.max(0, availW - 6);
    availH = Math.max(0, availH - 4);
  }

  // 4) Valitse neliölaudan käytettävä sivu
  const avail = Math.max(0, Math.min(availW, availH));

  // 5) Laske cell täsmälleen boardin kaavalla
  const cell = Math.floor((avail - (gap*7) - (pad*2) - 4) / 8);

  // Clamp kuten ennen
  const minCell = isIphonePortrait ? 28 : 34;
  const maxCell = 74;

  const clamped = Math.max(minCell, Math.min(maxCell, cell));

  document.documentElement.style.setProperty("--cell", clamped + "px");
  document.documentElement.style.setProperty("--gap", gap + "px");
  document.documentElement.style.setProperty("--boardPad", pad + "px");

  drawDiagonals();
}


    function dotOffset(cell){
      const scale = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--dotScale"));
      return -((scale - 1) / 2) * cell;
    }

    function xyToPx(x,y){
      const cell = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--cell"));
      const gap  = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--gap"));
      const pad  = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--boardPad"));
      const off  = dotOffset(cell);
      return {
        left: pad + x*(cell+gap) + off,
        top:  pad + y*(cell+gap) + off
      };
    }

    function buildGrid(){
      const elGrid = document.getElementById("grid");
      elGrid.innerHTML = "";
      for (let y=0; y<H; y++){
        for (let x=0; x<W; x++){
          const d = document.createElement("div");
          d.className = "cell";
          const off = ((y===0 || x===0) && !(x===0 && y===0));
          if (off) d.classList.add("off");
          if (isPlayable(x,y)) d.classList.add("playable");
          if (x===0 && y===0) d.classList.add("exit");

          d.addEventListener("pointerdown", (ev)=>{
            ev.preventDefault();
            if (!isPlayable(x,y)) return;
            onCellClick(x,y);
          });

          elGrid.appendChild(d);
        }
      }
    }

    /* --- puzzles state --- */
    let puzzles = [];
    let fileCurrent = 0;   // "current" jsonista
    let current = 0;

    let basePuzzle = null;
    let blocks = [];
    let pieces = [];

    // selection + hints
    let selectedId = null;
    let selectedMoves = [];
    let previewGroupIds = null; // Set of ids for the currently previewed group-move (drag/click)

    function deepClone(o){ return JSON.parse(JSON.stringify(o)); }

    function loadLocal(){
      try{
        const raw = localStorage.getItem(LS_KEY);
        return raw ? JSON.parse(raw) : null;
      }catch(e){ return null; }
    }
    function saveLocal(){
      try{
        localStorage.setItem(LS_KEY, JSON.stringify({ current }));
      }catch(e){}
    }

    async function loadPuzzlesAuto(){
      const res = await fetch(PUZZLES_URL, { cache: "no-store" });
      if (!res.ok) throw new Error("HTTP " + res.status);

      const obj = await res.json();
      if (!obj || !Array.isArray(obj.puzzles) || obj.puzzles.length===0) throw new Error("Virheellinen antivirus-puzzles.json");

      puzzles = obj.puzzles;
      fileCurrent = Math.max(0, Math.min((obj.current|0), puzzles.length-1));

      const loc = loadLocal();
      if (loc && Number.isFinite(loc.current)){
        current = Math.max(0, Math.min((loc.current|0), puzzles.length-1));
      }else{
        current = fileCurrent;
      }
    }

    function renderPuzzleSelect(){
      elPuzzleSelect.innerHTML = "";
      puzzles.forEach((p,i)=>{
        const opt = document.createElement("option");
        opt.value = String(i);
        opt.textContent = `${i+1}. ${p.name || "Pulma"}`;
        elPuzzleSelect.appendChild(opt);
      });
      elPuzzleSelect.value = String(current);
    }

    function applyPuzzle(idx){
      current = Math.max(0, Math.min(idx|0, puzzles.length-1));
      const pz = puzzles[current];

      basePuzzle = deepClone(pz);
      blocks = deepClone(pz.blocks || []);
      pieces = deepClone(pz.pieces || []);

      selectedId = null;
      selectedMoves = [];

      elPuzzleSelect.value = String(current);
      saveLocal();

      renderAll();
      setStatus(`${pz.name || ("Pulma " + (current+1))} (${current+1}/${puzzles.length})`, "warn");
    }

    function resetPuzzle(){
      if (!basePuzzle) return;
      blocks = deepClone(basePuzzle.blocks || []);
      pieces = deepClone(basePuzzle.pieces || []);
      selectedId = null;
      selectedMoves = [];
      renderAll();
      setStatus("Reset.", "warn");
    }

    /* --- occupancy --- */
    function buildOccMap(exceptId=null){
      const occ = new Map();

      // walls = all non-playable
      for (let y=0; y<H; y++){
        for (let x=0; x<W; x++){
          if (!isPlayable(x,y)) occ.set(key(x,y), "#");
        }
      }

      // blocks
      for (const b of blocks){
        occ.set(key(b.x,b.y), "B");
      }

      // pieces
      for (const p of pieces){
        if (exceptId!==null && p.id===exceptId) continue;
        for (const c of pieceCells(p)){
          occ.set(key(c.x,c.y), p.id);
        }
      }

      return occ;
    }

    /* --- test movement: diagonal slide, can stop at any free anchor along diagonal --- */
    const DIRS = [
      {dx: 1, dy: 1,  arrow:"↘"},
      {dx: 1, dy:-1, arrow:"↗"},
      {dx:-1, dy: 1, arrow:"↙"},
      {dx:-1, dy:-1,arrow:"↖"},
    ];

    function computeMovesForPiece(id){
      const p0 = pieces.find(pp=>pp.id===id);
      if (!p0) return [];

      const out = [];

      function cellsAt(p, dx, dy){
        return pieceCells({ id:p.id, rot:p.rot, x0:p.x0+dx, y0:p.y0+dy });
      }

      function buildOccExcluding(group){
        const occ = new Map();
        for (const b of blocks){
          occ.set(key(b.x,b.y), "B");
        }
        for (const p of pieces){
          if (group.has(p.id)) continue;
          for (const c of pieceCells(p)){
            occ.set(key(c.x,c.y), p.id);
          }
        }
        return occ;
      }

      for (const dir of DIRS){
        let step = 1;
        while (true){
          const dx = dir.dx * step;
          const dy = dir.dy * step;

          const group = new Set([id]);
          let changed = true;
          let blocked = false;

          while (changed){
            changed = false;
            const occ = buildOccExcluding(group);

            for (const pid of Array.from(group)){
              const p = pieces.find(pp=>pp.id===pid);
              for (const c of cellsAt(p, dx, dy)){
                if (!onBoard(c.x,c.y) || !isPlayable(c.x,c.y)){
                  blocked = true; break;
                }
                const o = occ.get(key(c.x,c.y));
                if (o!==undefined){
                  if (o==="B"){
                    blocked = true; break;
                  }
                  // collision with another piece -> add to group
                  if (!group.has(o)){
                    group.add(o);
                    changed = true;
                  }
                }
              }
              if (blocked) break;
            }
            if (blocked) break;
          }

          if (blocked) break;

          // also ensure no overlaps within group after move
          const seen = new Set();
          for (const pid of group){
            const p = pieces.find(pp=>pp.id===pid);
            for (const c of cellsAt(p, dx, dy)){
              const k = key(c.x,c.y);
              if (seen.has(k)){
                blocked = true; break;
              }
              seen.add(k);
            }
            if (blocked) break;
          }
          if (blocked) break;

          out.push({
            x0: p0.x0 + dx,
            y0: p0.y0 + dy,
            kind: "group",
            arrow: dir.arrow,
            group: Array.from(group).map(pid=>{
              const p = pieces.find(pp=>pp.id===pid);
              return { id:pid, x0:p.x0+dx, y0:p.y0+dy };
            })
          });

          step++;
        }
      }

      // Prefer moves with larger groups for same destination
      const best = new Map();
      for (const m of out){
        const k = m.x0 + "," + m.y0;
        const prev = best.get(k);
        if (!prev || m.group.length > prev.group.length){
          best.set(k, m);
        }
      }
      return Array.from(best.values());
    }

    function selectPiece(id){
      selectedId = id;
      selectedMoves = computeMovesForPiece(id);
      previewGroupIds = null;
      renderAll();
    }


    
    function setPreviewGroupFromMove(move){
      if (move && move.kind==="group" && Array.isArray(move.group)){
        previewGroupIds = new Set(move.group.map(g=>g.id));
      }else{
        previewGroupIds = null;
      }
    }

    function applyMove(move){
      if (move && move.kind==="group" && Array.isArray(move.group)){
        for (const g of move.group){
          const i = pieces.findIndex(pp=>pp.id===g.id);
          if (i>=0){
            pieces[i].x0 = g.x0;
            pieces[i].y0 = g.y0;
          }
        }
      }else if (move){
        const i = pieces.findIndex(pp=>pp.id===selectedId);
        if (i>=0){
          pieces[i].x0 = move.x0;
          pieces[i].y0 = move.y0;
        }
      }
    }

function clearSelection(){
      selectedId = null;
      selectedMoves = [];
      previewGroupIds = null;
      renderAll();
    }

    function onCellClick(x,y){
      if (selectedId===null) return;

      const target = selectedMoves.find(m => m.x0===x && m.y0===y);
      if (!target) return;

      setPreviewGroupFromMove(target);
      applyMove(target);

      selectedMoves = computeMovesForPiece(selectedId);
      previewGroupIds = null;

      if (checkWin()){
        setStatus("Voitto! Punainen on EXIT-ruudussa.", "ok");
      }else{
        setStatus(`${puzzles[current]?.name || ("Pulma " + (current+1))} (${current+1}/${puzzles.length})`, "warn");
      }

      renderAll();
    }

    function checkWin(){

      const red = pieces.find(p=>p.id===0);
      if (!red) return false;
      return pieceCells(red).some(c => c.x===0 && c.y===0);
    }

    /* --- render --- */
    function renderHints(){
      const el = document.getElementById("hintsLayer");
      el.innerHTML = "";
      // Vihjeympyrät poistettu
    }

    function renderBlocks(){
      const el = document.getElementById("blocksLayer");
      el.innerHTML = "";
      for (const b of blocks){
        const pos = xyToPx(b.x,b.y);
        const d = document.createElement("div");
        d.className = "dot blockDot";
        d.style.left = pos.left + "px";
        d.style.top  = pos.top  + "px";
        el.appendChild(d);
      }
    }

    let dragState = {
      active: false,
      startX: 0,
      startY: 0,
      pieceId: null,
      initialX0: null,
      initialY0: null,
	    stepPx: null,      // <-- LISÄÄ,
    };

    function drawPieceConnections(){
      const svg = document.getElementById("piecesConnections");
      svg.innerHTML = "";
      
      // Käy läpi kaikki nappulat
      for (const p of pieces){
        const def = PIECE_DEFS[p.id];
        const cells = pieceCells(p);
        
        // Jos nappula koostuu vain yhdestä solusta, ei tarvitse yhdistää
        if (cells.length <= 1) continue;
        
        // Yhdistä nappulan solut viivalla
        for (let i = 0; i < cells.length - 1; i++){
          const c1 = cells[i];
          const c2 = cells[i + 1];
          
          const pos1 = xyToPx(c1.x, c1.y);
          const pos2 = xyToPx(c2.x, c2.y);
          
          // Nappuloiden keskipisteet
          const cell = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--cell"));
          const scale = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--dotScale"));
          const x1 = pos1.left + (cell * scale) / 2;
          const y1 = pos1.top + (cell * scale) / 2;
          const x2 = pos2.left + (cell * scale) / 2;
          const y2 = pos2.top + (cell * scale) / 2;
          
          const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
          line.setAttribute("x1", x1);
          line.setAttribute("y1", y1);
          line.setAttribute("x2", x2);
          line.setAttribute("y2", y2);
          line.setAttribute("stroke", def.color);
          line.setAttribute("stroke-width", "36");
          line.setAttribute("stroke-linecap", "round");
          line.setAttribute("opacity", "0.7");
          svg.appendChild(line);
        }
      }
    }

    function renderPieces(){
      const el = document.getElementById("piecesLayer");
      el.innerHTML = "";
      for (const p of pieces){
        const def = PIECE_DEFS[p.id];
        const cells = pieceCells(p);
        for (const c of cells){
          const pos = xyToPx(c.x,c.y);
          const d = document.createElement("div");
          d.className = "dot pieceDot"
            + (p.id===selectedId ? " selected" : "")
            + (previewGroupIds && previewGroupIds.has(p.id) && p.id!==selectedId ? " grouped" : "");
          d.style.left = pos.left + "px";
          d.style.top  = pos.top  + "px";
          d.style.background = def.color;
          d.dataset.pid = String(p.id);

          d.addEventListener("pointerdown", (ev)=>{
            ev.preventDefault();
            const pid = parseInt(d.dataset.pid,10);
            
            // Käynnistä drag
            dragState.active = true;
            dragState.startX = ev.clientX;
            dragState.startY = ev.clientY;
            dragState.pieceId = pid;
            
            const piece = pieces.find(pp=>pp.id===pid);
            if (piece){
              dragState.initialX0 = piece.x0;
              dragState.initialY0 = piece.y0;
            }
            const rootCS = getComputedStyle(document.documentElement);
const cell = parseFloat(rootCS.getPropertyValue("--cell")) || 56;
const gap  = parseFloat(rootCS.getPropertyValue("--gap"))  || 8;
dragState.stepPx = cell + gap;

            // Valitse pala
            if (selectedId===pid) clearSelection();
            else selectPiece(pid);
          });

          el.appendChild(d);
        }
      }
    }

    function renderAll(){
      renderHints();
      renderBlocks();
      drawPieceConnections();
      renderPieces();
    }

    document.addEventListener("pointermove", (ev)=>{
      if (!dragState.active) return;

      const piece = pieces.find(pp=>pp.id===dragState.pieceId);
      if (!piece) return;

      // Laske liikkeen määrä pikseileissä
      const dx = ev.clientX - dragState.startX;
      const dy = ev.clientY - dragState.startY;

      // Muuta pikselit ruudukoordinaateiksi
// Muuta pikselit ruudukoordinaateiksi (oikea askel: cell+gap)
const step = dragState.stepPx || (() => {
  const rootCS = getComputedStyle(document.documentElement);
  const cell = parseFloat(rootCS.getPropertyValue("--cell")) || 56;
  const gap  = parseFloat(rootCS.getPropertyValue("--gap"))  || 8;
  return cell + gap;
})();

const gridX = Math.round(dx / step);
const gridY = Math.round(dy / step);

      // Laske uusi positio
      const newX0 = dragState.initialX0 + gridX;
      const newY0 = dragState.initialY0 + gridY;

      // Laske uudet sallitut liikkeet nykyisestä positiosta
      const moves = computeMovesForPiece(dragState.pieceId);
      const validMove = moves.find(m => m.x0 === newX0 && m.y0 === newY0);
      
      if (validMove){
        // Preview the whole group move while dragging
        setPreviewGroupFromMove(validMove);
        applyMove(validMove);
        selectedMoves = computeMovesForPiece(dragState.pieceId);
        renderAll();
      }else{
        previewGroupIds = null;
      }
    });

    document.addEventListener("pointerup", (ev)=>{
      if (!dragState.active){
        dragState.active = false;
        return;
      }

      dragState.active = false;

      // Tarkista voitto
      if (checkWin()){
        setStatus("Voitto! Punainen on EXIT-ruudussa.", "ok");
      }else{
        setStatus(`${puzzles[current]?.name || ("Pulma " + (current+1))} (${current+1}/${puzzles.length})`, "warn");
      }

      previewGroupIds = null;
      renderAll();
    });

    /* --- controls --- */
    btnPrev.addEventListener("click", ()=>{
      if (!puzzles.length) return;
      applyPuzzle((current - 1 + puzzles.length) % puzzles.length);
    });

    btnNext.addEventListener("click", ()=>{
      if (!puzzles.length) return;
      applyPuzzle((current + 1) % puzzles.length);
    });

    elPuzzleSelect.addEventListener("change", ()=>{
      const idx = parseInt(elPuzzleSelect.value, 10);
      if (!Number.isFinite(idx)) return;
      applyPuzzle(idx);
    });

    btnReset.addEventListener("click", resetPuzzle);

    btnExample.addEventListener("click", ()=>{
      if (!puzzles.length) return;
      applyPuzzle(fileCurrent || 0);
    });

    btnHelp.addEventListener("click", ()=>{
      alert(
        "Pulman valinta: ◀ / valikko / ▶ (tai näppäimet ← →)\n\n" +
        "Testimekaniikka: valitse pala klikkaamalla sen ympyrää → klikkaa korostettua kohderuutua (diagonaalinen liuku).\n\n" +
        "Voitto: punainen (id 0) peittää EXIT-ruudun."
      );
    });

    window.addEventListener("keydown", (e)=>{
      if (!puzzles.length) return;
      if (e.key === "ArrowLeft")  applyPuzzle((current - 1 + puzzles.length) % puzzles.length);
      if (e.key === "ArrowRight") applyPuzzle((current + 1) % puzzles.length);
      if (e.key === "r" || e.key === "R") resetPuzzle();
    });

    /* --- init --- */
    (async function init(){
      mountBoard();
      rebuildCellSize();
      buildGrid();

      window.addEventListener("resize", ()=>{
        rebuildCellSize();
        renderAll();
      });

      try{
        await loadPuzzlesAuto();
        renderPuzzleSelect();
        applyPuzzle(current);
      }catch(e){
        // Ei piiloteta virhettä: näytetään suoraan statusriviin
        setStatus("Ei ladattu antivirus-puzzles.json: " + (e?.message || "virhe"), "bad");
        puzzles = [];
        elPuzzleSelect.innerHTML = "";
      }
    })();
  </script>
</body>
</html>
