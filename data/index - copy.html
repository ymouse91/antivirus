<!doctype html>
<html lang="fi">
<head>
  <meta charset="utf-8" />

  <!-- iOS: viewport-fit=cover on pakko safe-areaa varten -->
  <meta name="viewport"
        content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover">

  <!-- PWA perus -->
  <link rel="manifest" href="manifest.webmanifest">
  <meta name="theme-color" content="#0b1533"> <!-- Android/Chrome -->
  <meta name="color-scheme" content="dark light">

  <!-- iOS PWA -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Peli">

  <!-- Icons -->
  <link rel="icon" href="icon192.png">
  <link rel="apple-touch-icon" href="icon192.png">

  <style>
    :root{
      --bg: #0b1533;
      --ink: #eaf0ff;

      /* JS asettaa --vh */
      --vh: 1vh;

      /* safe area */
      --sat: env(safe-area-inset-top);
      --sar: env(safe-area-inset-right);
      --sab: env(safe-area-inset-bottom);
      --sal: env(safe-area-inset-left);

      /* game sizing */
      --cell: 56px;
      --gap: 8px;
      --boardPad: 10px;

      /* dots */
      --dotScale: 1.30;
      --dotBorder: 2px;

      --good: #49e2a8;
      --bad:  #ff5a6a;
      --warn: #ffd35a;
    }

    /* TÄRKEÄ: html-tausta estää valkoiset “nauhat” kuminauhassa */
    html{
      height: 100%;
      background: var(--bg);
      background-color: var(--bg);
    }

    body{
      margin:0;
      height: 100%;
      min-height: calc(var(--vh) * 100);
      background: var(--bg);
      color: var(--ink);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background:linear-gradient(135deg,#0f172a 0%,#1a2a4a 50%,#0f172a 100%);
      overflow: hidden;
      overscroll-behavior: none;

      -webkit-text-size-adjust: 100%;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }

    /* App-container hoitaa safe-areat (ei body!) */
    #app{
      position: fixed;
      inset: 0;
      padding: max(12px, var(--sat)) max(12px, var(--sar)) max(12px, var(--sab)) max(12px, var(--sal));
      display: grid;
      grid-template-rows: auto 1fr auto;
      gap: 10px;
      background: radial-gradient(1200px 800px at 30% 10%, #162a67 0%, var(--bg) 55%, #070c1d 100%);
    }

    header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      min-width:0;
    }

    .title{
      display:flex;
      gap:10px;
      align-items:baseline;
      min-width:0;
    }
    .title h1{ margin:0; font-size:22px; white-space:nowrap; }
    .title .sub{ font-size:12px; opacity:.85; font-weight:900; }

    .controls{
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
      justify-content:flex-end;
    }

    button, select{ font: inherit; color: var(--ink); }

    button{
      background: rgba(255,255,255,.10);
      border: 1px solid rgba(255,255,255,.20);
      border-radius: 10px;
      padding: 8px 10px;
      font-weight: 900;
      cursor:pointer;
      user-select:none;
    }
    button:active{ transform: translateY(1px); }
    button:disabled{ opacity:.45; cursor:default; transform:none; }

    select{
      background: rgba(0,0,0,.18);
      border: 1px solid rgba(255,255,255,.18);
      border-radius: 10px;
      padding: 8px 10px;
      font-weight: 900;
      outline:none;
      min-width: 240px;
      max-width: min(56vw, 420px);
    }

    main{
      min-height: 0;
      display:flex;
      align-items:center;
      justify-content:center;
    }

    #game{
      width:100%;
      height:100%;
      display:flex;
      align-items:center;
      justify-content:center;
    }

    #board{
      position: relative;
      width: calc(var(--cell) * 8 + var(--gap) * 7 + var(--boardPad) * 2);
      height: calc(var(--cell) * 8 + var(--gap) * 7 + var(--boardPad) * 2);
      border-radius: 18px;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.14);
      box-shadow: 0 18px 40px rgba(0,0,0,.28);
      padding: var(--boardPad);
      touch-action: none;
      user-select:none;
    }

    #exitTag{
      position:absolute;
      /* EXIT on ruudulla A1 (0,0) */
      left: var(--boardPad);
      top: var(--boardPad);
      width: var(--cell);
      height: var(--cell);
      /* Keskitä teksti flex-boxilla */
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      font-weight: 1000;
      opacity:.9;
      border-radius: 999px;
      background: rgba(73,226,168,.15);
      border: 1px solid rgba(73,226,168,.35);
      pointer-events:none;
      text-align: center;
    }

    #grid{
      position:absolute;
      inset: var(--boardPad);
      display:grid;
      grid-template-columns: repeat(8, var(--cell));
      grid-template-rows: repeat(8, var(--cell));
      gap: var(--gap);
    }

    .cell{
      border-radius: 999px;
      background: rgba(0,0,0,.22);
      border: 1px solid rgba(255,255,255,.06);
      opacity:.55;
      position:relative;
    }
    .cell.playable{
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.22);
      opacity: 1;
      cursor:pointer;
    }
    .cell.off{
      background: rgba(0,0,0,.34);
      border: 1px solid rgba(255,255,255,.05);
      opacity: .45;
    }
    .cell.exit{
      outline: 7px solid rgba(73,226,168,.45);
      outline-offset: -1px;
    }

    .hint{
      position:absolute;
      inset: 18%;
      border-radius: 999px;
      border: 3px solid rgba(255,255,255,.78);
      box-shadow: 0 0 0 2px rgba(0,0,0,.18) inset;
      pointer-events:none;
      opacity:.95;
    }

    .dot{
      position:absolute;
      width: calc(var(--cell) * var(--dotScale));
      height: calc(var(--cell) * var(--dotScale));
      border-radius: 999px;
      box-sizing:border-box;
      border: var(--dotBorder) solid rgba(255,255,255,.35);
      box-shadow: 0 10px 20px rgba(0,0,0,.25);
    }
    .pieceDot{ cursor:pointer; }
    .pieceDot.selected{
      outline: 3px solid rgba(255,255,255,.90);
      outline-offset: 2px;
    }
    .pieceDot.dragging{
      opacity: 0.8;
      filter: drop-shadow(0 0 8px rgba(255,255,255,0.3));
    }
    .blockDot{
      border: var(--dotBorder) solid rgba(0,0,0,.18);
      background: rgba(255,255,255,.92);
      cursor: default;
      pointer-events:none;
    }

    footer{ text-align:center; opacity:.95; font-weight:900; }
    footer.ok{ color: var(--good); }
    footer.bad{ color: var(--bad); }
    footer.warn{ color: var(--warn); }

    /* iPhone portrait: tilaa pienemmäksi, fontteja alas */
    @media (max-width: 430px) and (orientation: portrait) and (hover:none) and (pointer:coarse){
      #app{ gap: 8px; padding: max(10px, var(--sat)) 10px max(10px, var(--sab)); }
      .title h1{ font-size: 18px; }
      select{ min-width: 170px; padding: 7px 9px; }
      button{ padding: 7px 9px; }
    }
  </style>
</head>

<body>
  <div id="app">
    <header>
      <div class="title">
        <h1>Anti-Virus</h1>
        <div class="sub">mekaniikkatesti</div>
      </div>

      <div class="controls">
        <button id="btnPrev" title="Edellinen pulma">◀</button>
        <select id="puzzleSelect" aria-label="Valitse pulma"></select>
        <button id="btnNext" title="Seuraava pulma">▶</button>

        <button id="btnReset">Reset</button>
        <button id="btnExample" style="display:none">Esimerkki</button>
        <button id="btnHelp">Ohjeet</button>
      </div>
    </header>

    <main>
      <div id="game"></div>
    </main>

    <footer id="status" class="warn">Ladataan…</footer>
  </div>

  <script>
    // iOS viewport-korkeus oikein (estää valkoisia nauhoja ja “kuminauhaa”)
    function setVH(){
      document.documentElement.style.setProperty("--vh", (window.innerHeight * 0.01) + "px");
    }
    setVH();
    window.addEventListener("resize", setVH);

    // iOS: estä “double tap zoom” (usein peleissä toivottu)
    let lastTouchEnd = 0;
    document.addEventListener("touchend", (e) => {
      const now = Date.now();
      if (now - lastTouchEnd < 300) e.preventDefault();
      lastTouchEnd = now;
    }, { passive:false });
  </script>

  <script>
    // SW rekisteröinti (PWA/offline)
    if ("serviceWorker" in navigator){
      navigator.serviceWorker.register("./sw.js", { scope: "./" }).catch(()=>{});
    }
  </script>

  <script>
    /* =========================
       Anti-Virus: puzzles + test-mekaniikka
       ========================= */

    const PUZZLES_URL = "antivirus-puzzles.json";
    const LS_KEY = "antivirus_play_v1";

    /* --- board rules --- */
    const W=8, H=8;
    function onBoard(x,y){ return x>=0 && x<W && y>=0 && y<H; }
    function isWhite(x,y){ return ((x+y)&1)===0; } // A1 (0,0) valkea

    // Käytössä vain valkeat B–H ja 2–8, plus EXIT A1.
    function isPlayable(x,y){
      if (!onBoard(x,y)) return false;
      if (x===0 && y===0) return true; // EXIT
      if (y===0) return false;         // rivi 1 pois
      if (x===0) return false;         // sarake A pois
      return isWhite(x,y);
    }
    function key(x,y){ return `${x},${y}`; }

    /* --- piece defs (lukittu, kuten sovittu) --- */
    const PIECE_DEFS = {
      0: { id:0, name:"Punainen",     color:"#ff3b3b", shape:[[0,0],[1,1]] },
      1: { id:1, name:"Vaaleansin.",  color:"#4ecbff", shape:[[0,0],[1,1]] },
      2: { id:2, name:"Oranssi",      color:"#ff9f1c", shape:[[0,0],[1,1],[0,2]] },
      3: { id:3, name:"Pinkki",       color:"#ff7abf", shape:[[0,0],[0,2]] },
      4: { id:4, name:"Tummanvihreä", color:"#2ecc71", shape:[[0,0],[0,2]] },
      5: { id:5, name:"Tummansininen",color:"#1f5fbf", shape:[[0,0],[2,0],[4,0]] },
      6: { id:6, name:"Violetti",     color:"#b06cff", shape:[[0,0],[2,0],[2,2]] },
      7: { id:7, name:"Lime",         color:"#b7e600", shape:[[0,0],[1,1],[1,3]] },
      8: { id:8, name:"Keltainen",    color:"#ffd400", shape:[[0,0],[-1,1],[-1,3]] },
    };

    /* --- rotation: 90° CCW steps, no normalization on board --- */
    function rotPtCCW(dx, dy, steps){
      const r = ((steps%4)+4)%4;
      if (r===0) return [dx, dy];
      if (r===1) return [-dy, dx];
      if (r===2) return [-dx, -dy];
      return [dy, -dx]; // r===3
    }
    function rotatedPointsNoNorm(points, rotSteps){
      return points.map(([dx,dy]) => rotPtCCW(dx,dy,rotSteps));
    }
    function pieceCells(piece){
      const def = PIECE_DEFS[piece.id];
      const pts = rotatedPointsNoNorm(def.shape, piece.rot|0);
      return pts.map(([dx,dy]) => ({ x: piece.x0 + dx, y: piece.y0 + dy }));
    }

    /* --- UI refs --- */
    const elGame = document.getElementById("game");
    const elStatus = document.getElementById("status");
    const elPuzzleSelect = document.getElementById("puzzleSelect");
    const btnPrev = document.getElementById("btnPrev");
    const btnNext = document.getElementById("btnNext");
    const btnReset = document.getElementById("btnReset");
    const btnExample = document.getElementById("btnExample");
    const btnHelp = document.getElementById("btnHelp");

    function setStatus(msg, cls="warn"){
      elStatus.textContent = msg || "";
      elStatus.className = cls;
    }

    /* --- mount board --- */
    function mountBoard(){
      elGame.innerHTML = `
        <div id="board">
          <svg id="diagonalsLayer" style="position:absolute; inset:0; pointer-events:none; width:100%; height:100%;">
            <g id="diagonals"></g>
          </svg>
          <svg id="piecesConnectionLayer" style="position:absolute; inset:0; pointer-events:none; width:100%; height:100%;">
            <g id="piecesConnections"></g>
          </svg>
          <div id="exitTag">EXIT</div>
          <div id="grid"></div>
          <div id="hintsLayer"></div>
          <div id="blocksLayer"></div>
          <div id="piecesLayer"></div>
        </div>
      `;
      drawDiagonals();
    }

    function drawDiagonals(){
      const svg = document.getElementById("diagonals");
      svg.innerHTML = "";
      
      const cell = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--cell"));
      const gap = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--gap"));
      const pad = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--boardPad"));
      
      // Diagonaalit neljään suuntaan
      for (let i = 0; i < 8; i++){
        for (let j = 0; j < 8; j++){
          // Näytä vain ruudot joissa on validi peli
          if (!isPlayable(i,j)) continue;
          
          // Käytä ruudukon solun keskipistettä (ilman nappuloiden offsetia)
          const centerX = pad + i*(cell+gap) + cell/2;
          const centerY = pad + j*(cell+gap) + cell/2;
          
          // Neljä diagonaalia: yläoikea, alaoikea, alavasen, ylävasen
          const dirs = [
            {dx: 1, dy: -1},  // yläoikea
            {dx: 1, dy: 1},   // alaoikea
            {dx: -1, dy: 1},  // alavasen
            {dx: -1, dy: -1}  // ylävasen
          ];
          
          for (const dir of dirs){
            // Piirretään viiva seuraavaan ruutuun
            const nextI = i + dir.dx;
            const nextJ = j + dir.dy;
            
            if (nextI >= 0 && nextI < 8 && nextJ >= 0 && nextJ < 8 && isPlayable(nextI, nextJ)){
              const nextCenterX = pad + nextI*(cell+gap) + cell/2;
              const nextCenterY = pad + nextJ*(cell+gap) + cell/2;
              
              // Piirretään viiva
              const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
              line.setAttribute("x1", centerX);
              line.setAttribute("y1", centerY);
              line.setAttribute("x2", nextCenterX);
              line.setAttribute("y2", nextCenterY);
              line.setAttribute("stroke", "rgba(255,255,255,0.15)");
              line.setAttribute("stroke-width", "1.5");
              line.setAttribute("stroke-dasharray", "3,2");
              svg.appendChild(line);
            }
          }
        }
      }
    }

    /* --- responsive cell size --- */
    function rebuildCellSize(){
      const wrap = elGame.getBoundingClientRect();
      const avail = Math.min(wrap.width, wrap.height);
      const gap = 8;
      const pad = 10;
      const cell = Math.floor((avail - (gap*7) - (pad*2) - 4) / 8);
      const clamped = Math.max(34, Math.min(74, cell));
      document.documentElement.style.setProperty("--cell", clamped + "px");
      document.documentElement.style.setProperty("--gap", gap + "px");
      document.documentElement.style.setProperty("--boardPad", pad + "px");
      drawDiagonals();
    }

    function dotOffset(cell){
      const scale = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--dotScale"));
      return -((scale - 1) / 2) * cell;
    }

    function xyToPx(x,y){
      const cell = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--cell"));
      const gap  = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--gap"));
      const pad  = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--boardPad"));
      const off  = dotOffset(cell);
      return {
        left: pad + x*(cell+gap) + off,
        top:  pad + y*(cell+gap) + off
      };
    }

    function buildGrid(){
      const elGrid = document.getElementById("grid");
      elGrid.innerHTML = "";
      for (let y=0; y<H; y++){
        for (let x=0; x<W; x++){
          const d = document.createElement("div");
          d.className = "cell";
          const off = ((y===0 || x===0) && !(x===0 && y===0));
          if (off) d.classList.add("off");
          if (isPlayable(x,y)) d.classList.add("playable");
          if (x===0 && y===0) d.classList.add("exit");

          d.addEventListener("pointerdown", (ev)=>{
            ev.preventDefault();
            if (!isPlayable(x,y)) return;
            onCellClick(x,y);
          });

          elGrid.appendChild(d);
        }
      }
    }

    /* --- puzzles state --- */
    let puzzles = [];
    let fileCurrent = 0;   // "current" jsonista
    let current = 0;

    let basePuzzle = null;
    let blocks = [];
    let pieces = [];

    // selection + hints
    let selectedId = null;
    let selectedMoves = [];

    function deepClone(o){ return JSON.parse(JSON.stringify(o)); }

    function loadLocal(){
      try{
        const raw = localStorage.getItem(LS_KEY);
        return raw ? JSON.parse(raw) : null;
      }catch(e){ return null; }
    }
    function saveLocal(){
      try{
        localStorage.setItem(LS_KEY, JSON.stringify({ current }));
      }catch(e){}
    }

    async function loadPuzzlesAuto(){
      const res = await fetch(PUZZLES_URL, { cache: "no-store" });
      if (!res.ok) throw new Error("HTTP " + res.status);

      const obj = await res.json();
      if (!obj || !Array.isArray(obj.puzzles) || obj.puzzles.length===0) throw new Error("Virheellinen antivirus-puzzles.json");

      puzzles = obj.puzzles;
      fileCurrent = Math.max(0, Math.min((obj.current|0), puzzles.length-1));

      const loc = loadLocal();
      if (loc && Number.isFinite(loc.current)){
        current = Math.max(0, Math.min((loc.current|0), puzzles.length-1));
      }else{
        current = fileCurrent;
      }
    }

    function renderPuzzleSelect(){
      elPuzzleSelect.innerHTML = "";
      puzzles.forEach((p,i)=>{
        const opt = document.createElement("option");
        opt.value = String(i);
        opt.textContent = `${i+1}. ${p.name || "Pulma"}`;
        elPuzzleSelect.appendChild(opt);
      });
      elPuzzleSelect.value = String(current);
    }

    function applyPuzzle(idx){
      current = Math.max(0, Math.min(idx|0, puzzles.length-1));
      const pz = puzzles[current];

      basePuzzle = deepClone(pz);
      blocks = deepClone(pz.blocks || []);
      pieces = deepClone(pz.pieces || []);

      selectedId = null;
      selectedMoves = [];

      elPuzzleSelect.value = String(current);
      saveLocal();

      renderAll();
      setStatus(`${pz.name || ("Pulma " + (current+1))} (${current+1}/${puzzles.length})`, "warn");
    }

    function resetPuzzle(){
      if (!basePuzzle) return;
      blocks = deepClone(basePuzzle.blocks || []);
      pieces = deepClone(basePuzzle.pieces || []);
      selectedId = null;
      selectedMoves = [];
      renderAll();
      setStatus("Reset.", "warn");
    }

    /* --- occupancy --- */
    function buildOccMap(exceptId=null){
      const occ = new Map();

      // walls = all non-playable
      for (let y=0; y<H; y++){
        for (let x=0; x<W; x++){
          if (!isPlayable(x,y)) occ.set(key(x,y), "#");
        }
      }

      // blocks
      for (const b of blocks){
        occ.set(key(b.x,b.y), "B");
      }

      // pieces
      for (const p of pieces){
        if (exceptId!==null && p.id===exceptId) continue;
        for (const c of pieceCells(p)){
          occ.set(key(c.x,c.y), p.id);
        }
      }

      return occ;
    }

    /* --- test movement: diagonal slide, can stop at any free anchor along diagonal --- */
    const DIRS = [
      {dx: 1, dy: 1},
      {dx: 1, dy:-1},
      {dx:-1, dy: 1},
      {dx:-1, dy:-1},
    ];

    function computeMovesForPiece(id){
      const p = pieces.find(pp=>pp.id===id);
      if (!p) return [];

      const occ = buildOccMap(id);
      const out = [];
      const seen = new Set();

      for (const dir of DIRS){
        let step = 1;
        while (true){
          const cand = { id:p.id, rot:p.rot, x0: p.x0 + dir.dx*step, y0: p.y0 + dir.dy*step };

          let ok = true;
          for (const c of pieceCells(cand)){
            if (!onBoard(c.x,c.y) || !isPlayable(c.x,c.y)) { ok=false; break; }
            if (occ.has(key(c.x,c.y))) { ok=false; break; }
          }
          if (!ok) break;

          const k = key(cand.x0, cand.y0) + "|" + cand.rot;
          if (!seen.has(k)){
            seen.add(k);
            out.push({x0:cand.x0, y0:cand.y0});
          }
          step++;
        }
      }
      return out;
    }

    function selectPiece(id){
      selectedId = id;
      selectedMoves = computeMovesForPiece(id);
      renderAll();
    }

    function clearSelection(){
      selectedId = null;
      selectedMoves = [];
      renderAll();
    }

    function onCellClick(x,y){
      if (selectedId===null) return;
      const target = selectedMoves.find(m => m.x0===x && m.y0===y);
      if (!target) return;

      const idx = pieces.findIndex(pp=>pp.id===selectedId);
      if (idx<0) return;

      pieces[idx].x0 = target.x0;
      pieces[idx].y0 = target.y0;

      selectedMoves = computeMovesForPiece(selectedId);

      if (checkWin()){
        setStatus("Voitto! Punainen on EXIT-ruudussa.", "ok");
      }else{
        setStatus(`${puzzles[current]?.name || ("Pulma " + (current+1))} (${current+1}/${puzzles.length})`, "warn");
      }

      renderAll();
    }

    function checkWin(){
      const red = pieces.find(p=>p.id===0);
      if (!red) return false;
      return pieceCells(red).some(c => c.x===0 && c.y===0);
    }

    /* --- render --- */
    function renderHints(){
      const el = document.getElementById("hintsLayer");
      el.innerHTML = "";
      // Vihjeympyrät poistettu
    }

    function renderBlocks(){
      const el = document.getElementById("blocksLayer");
      el.innerHTML = "";
      for (const b of blocks){
        const pos = xyToPx(b.x,b.y);
        const d = document.createElement("div");
        d.className = "dot blockDot";
        d.style.left = pos.left + "px";
        d.style.top  = pos.top  + "px";
        el.appendChild(d);
      }
    }

    let dragState = {
      active: false,
      startX: 0,
      startY: 0,
      pieceId: null,
      initialX0: null,
      initialY0: null,
    };

    function drawPieceConnections(){
      const svg = document.getElementById("piecesConnections");
      svg.innerHTML = "";
      
      // Käy läpi kaikki nappulat
      for (const p of pieces){
        const def = PIECE_DEFS[p.id];
        const cells = pieceCells(p);
        
        // Jos nappula koostuu vain yhdestä solusta, ei tarvitse yhdistää
        if (cells.length <= 1) continue;
        
        // Yhdistä nappulan solut viivalla
        for (let i = 0; i < cells.length - 1; i++){
          const c1 = cells[i];
          const c2 = cells[i + 1];
          
          const pos1 = xyToPx(c1.x, c1.y);
          const pos2 = xyToPx(c2.x, c2.y);
          
          // Nappuloiden keskipisteet
          const cell = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--cell"));
          const scale = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--dotScale"));
          const x1 = pos1.left + (cell * scale) / 2;
          const y1 = pos1.top + (cell * scale) / 2;
          const x2 = pos2.left + (cell * scale) / 2;
          const y2 = pos2.top + (cell * scale) / 2;
          
          const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
          line.setAttribute("x1", x1);
          line.setAttribute("y1", y1);
          line.setAttribute("x2", x2);
          line.setAttribute("y2", y2);
          line.setAttribute("stroke", def.color);
          line.setAttribute("stroke-width", "40");
          line.setAttribute("stroke-linecap", "round");
          line.setAttribute("opacity", "0.7");
          svg.appendChild(line);
        }
      }
    }

    function renderPieces(){
      const el = document.getElementById("piecesLayer");
      el.innerHTML = "";
      for (const p of pieces){
        const def = PIECE_DEFS[p.id];
        const cells = pieceCells(p);
        for (const c of cells){
          const pos = xyToPx(c.x,c.y);
          const d = document.createElement("div");
          d.className = "dot pieceDot" + (p.id===selectedId ? " selected" : "");
          d.style.left = pos.left + "px";
          d.style.top  = pos.top  + "px";
          d.style.background = def.color;
          d.dataset.pid = String(p.id);

          d.addEventListener("pointerdown", (ev)=>{
            ev.preventDefault();
            const pid = parseInt(d.dataset.pid,10);
            
            // Käynnistä drag
            dragState.active = true;
            dragState.startX = ev.clientX;
            dragState.startY = ev.clientY;
            dragState.pieceId = pid;
            
            const piece = pieces.find(pp=>pp.id===pid);
            if (piece){
              dragState.initialX0 = piece.x0;
              dragState.initialY0 = piece.y0;
            }
            
            // Valitse pala
            if (selectedId===pid) clearSelection();
            else selectPiece(pid);
          });

          el.appendChild(d);
        }
      }
    }

    function renderAll(){
      renderHints();
      renderBlocks();
      drawPieceConnections();
      renderPieces();
    }

    document.addEventListener("pointermove", (ev)=>{
      if (!dragState.active) return;

      const piece = pieces.find(pp=>pp.id===dragState.pieceId);
      if (!piece) return;

      // Laske liikkeen määrä pikseileissä
      const dx = ev.clientX - dragState.startX;
      const dy = ev.clientY - dragState.startY;

      // Muuta pikselit ruudukoordinaateiksi
      const cellSize = 64; // suurin piirtein, perustuu --cell-muuttujaan
      const gridX = Math.round(dx / cellSize);
      const gridY = Math.round(dy / cellSize);

      // Laske uusi positio
      const newX0 = dragState.initialX0 + gridX;
      const newY0 = dragState.initialY0 + gridY;

      // Laske uudet sallitut liikkeet nykyisestä positiosta
      const moves = computeMovesForPiece(dragState.pieceId);
      const validMove = moves.find(m => m.x0 === newX0 && m.y0 === newY0);
      
      if (validMove){
        piece.x0 = newX0;
        piece.y0 = newY0;
        // Päivitä selectedMoves niin että voi jatkaa raahaamista
        selectedMoves = computeMovesForPiece(dragState.pieceId);
        renderAll();
      }
    });

    document.addEventListener("pointerup", (ev)=>{
      if (!dragState.active){
        dragState.active = false;
        return;
      }

      dragState.active = false;

      // Tarkista voitto
      if (checkWin()){
        setStatus("Voitto! Punainen on EXIT-ruudussa.", "ok");
      }else{
        setStatus(`${puzzles[current]?.name || ("Pulma " + (current+1))} (${current+1}/${puzzles.length})`, "warn");
      }

      renderAll();
    });

    /* --- controls --- */
    btnPrev.addEventListener("click", ()=>{
      if (!puzzles.length) return;
      applyPuzzle((current - 1 + puzzles.length) % puzzles.length);
    });

    btnNext.addEventListener("click", ()=>{
      if (!puzzles.length) return;
      applyPuzzle((current + 1) % puzzles.length);
    });

    elPuzzleSelect.addEventListener("change", ()=>{
      const idx = parseInt(elPuzzleSelect.value, 10);
      if (!Number.isFinite(idx)) return;
      applyPuzzle(idx);
    });

    btnReset.addEventListener("click", resetPuzzle);

    btnExample.addEventListener("click", ()=>{
      if (!puzzles.length) return;
      applyPuzzle(fileCurrent || 0);
    });

    btnHelp.addEventListener("click", ()=>{
      alert(
        "Pulman valinta: ◀ / valikko / ▶ (tai näppäimet ← →)\n\n" +
        "Testimekaniikka: valitse pala klikkaamalla sen ympyrää → klikkaa korostettua kohderuutua (diagonaalinen liuku).\n\n" +
        "Voitto: punainen (id 0) peittää EXIT-ruudun."
      );
    });

    window.addEventListener("keydown", (e)=>{
      if (!puzzles.length) return;
      if (e.key === "ArrowLeft")  applyPuzzle((current - 1 + puzzles.length) % puzzles.length);
      if (e.key === "ArrowRight") applyPuzzle((current + 1) % puzzles.length);
      if (e.key === "r" || e.key === "R") resetPuzzle();
    });

    /* --- init --- */
    (async function init(){
      mountBoard();
      rebuildCellSize();
      buildGrid();

      window.addEventListener("resize", ()=>{
        rebuildCellSize();
        renderAll();
      });

      try{
        await loadPuzzlesAuto();
        renderPuzzleSelect();
        applyPuzzle(current);
      }catch(e){
        // Ei piiloteta virhettä: näytetään suoraan statusriviin
        setStatus("Ei ladattu antivirus-puzzles.json: " + (e?.message || "virhe"), "bad");
        puzzles = [];
        elPuzzleSelect.innerHTML = "";
      }
    })();
  </script>
</body>
</html>
