<!doctype html>
<html lang="fi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport"
        content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover">
  <meta name="theme-color" content="#0b1533">
  <meta name="color-scheme" content="dark light">
  <title>Anti-Virus – Builder</title>

  <style>
    :root{
      --bg:#0b1533;
      --ink:#eaf0ff;
      --panel: rgba(255,255,255,.08);

      --sat: env(safe-area-inset-top);
      --sar: env(safe-area-inset-right);
      --sab: env(safe-area-inset-bottom);
      --sal: env(safe-area-inset-left);

      --cell: 54px;
      --gap: 8px;
      --boardPad: 10px;

      --dotScale: 1.30; /* isot osumapinnat */
      --dotBorder: 2px;

      --cellPlayable: rgba(255,255,255,.08);
      --cellRing: rgba(255,255,255,.20);
      --cellOff: rgba(0,0,0,.34);

      --sel: rgba(255,255,255,.88);
      --bad:#ff5a6a;
      --good:#49e2a8;
      --warn:#ffd35a;
    }

    html,body{
      height:100%;
      margin:0;
      background: var(--bg);
      color: var(--ink);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      overflow:hidden;
      overscroll-behavior:none;
      -webkit-text-size-adjust:100%;
      -webkit-tap-highlight-color:transparent;
    }

    #app{
      position:fixed;
      inset:0;
      padding: max(12px, var(--sat)) max(12px, var(--sar)) max(12px, var(--sab)) max(12px, var(--sal));
      display:grid;
      grid-template-rows: auto 1fr;
      gap: 10px;
      background: radial-gradient(1200px 800px at 30% 10%, #162a67 0%, var(--bg) 55%, #070c1d 100%);
    }

    header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      user-select:none;
    }

    header h1{
      margin:0;
      font-size: 20px;
      display:flex;
      gap:10px;
      align-items:baseline;
      white-space:nowrap;
    }
    header .sub{
      font-size: 12px;
      opacity:.85;
      font-weight:700;
    }

    .btnbar{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      justify-content:flex-end;
    }

    button, select, input, textarea{
      font: inherit;
      color: var(--ink);
    }

    button{
      background: rgba(255,255,255,.10);
      border: 1px solid rgba(255,255,255,.20);
      border-radius: 10px;
      padding: 8px 10px;
      font-weight: 800;
      cursor:pointer;
      user-select:none;
    }
    button:active{ transform: translateY(1px); }
    button:disabled{ opacity:.45; cursor: default; transform:none; }

    .card{
      background: var(--panel);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 14px;
      padding: 10px;
      box-shadow: 0 14px 30px rgba(0,0,0,.25);
    }

    main{
      min-height:0;
      display:grid;
      grid-template-columns: 1fr 340px;
      gap: 12px;
      align-items:stretch;
    }

    /* BOARD */
    #boardWrap{
      display:flex;
      align-items:center;
      justify-content:center;
      min-height:0;
    }

    #board{
      position: relative;
      width: calc(var(--cell) * 8 + var(--gap) * 7 + var(--boardPad) * 2);
      height: calc(var(--cell) * 8 + var(--gap) * 7 + var(--boardPad) * 2);
      border-radius: 18px;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.14);
      box-shadow: 0 18px 40px rgba(0,0,0,.28);
      padding: var(--boardPad);
      touch-action: none;
    }

    #exitTag{
      position:absolute;
      left: 10px;
      top: 8px;
      font-size: 11px;
      font-weight: 900;
      opacity:.9;
      padding: 3px 8px;
      border-radius: 999px;
      background: rgba(73,226,168,.15);
      border: 1px solid rgba(73,226,168,.35);
      pointer-events:none;
    }

    #grid{
      position:absolute;
      inset: var(--boardPad);
      display:grid;
      grid-template-columns: repeat(8, var(--cell));
      grid-template-rows: repeat(8, var(--cell));
      gap: var(--gap);
    }

    .cell{
      border-radius: 999px;
      background: rgba(0,0,0,.22);
      border: 1px solid rgba(255,255,255,.06);
      opacity:.55;
      position:relative;
      cursor:pointer;
    }
    .cell.playable{
      background: var(--cellPlayable);
      border: 1px solid var(--cellRing);
      opacity: 1;
    }
    .cell.off{
      background: var(--cellOff);
      border: 1px solid rgba(255,255,255,.05);
      opacity: .45;
      cursor: default;
    }
    .cell.exit{
      outline: 2px solid rgba(73,226,168,.45);
      outline-offset: 2px;
    }

    /* Dots */
    .dot{
      position:absolute;
      width: calc(var(--cell) * var(--dotScale));
      height: calc(var(--cell) * var(--dotScale));
      border-radius: 999px;
      box-sizing:border-box;
      border: var(--dotBorder) solid rgba(255,255,255,.35);
      box-shadow: 0 10px 20px rgba(0,0,0,.25);
      user-select:none;
    }
    .pieceDot{ pointer-events:auto; cursor:pointer; }
    .pieceDot.selected{
      outline: 3px solid var(--sel);
      outline-offset: 2px;
    }
    .blockDot{
      pointer-events:auto;
      cursor:pointer;
      border: var(--dotBorder) solid rgba(0,0,0,.18);
      box-shadow: 0 10px 18px rgba(0,0,0,.22);
    }

    /* SIDE */
    #side{
      min-height:0;
      display:flex;
      flex-direction:column;
      gap: 10px;
    }

    .row{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:space-between;
    }
    .label{
      font-size: 12px;
      font-weight:900;
      opacity:.9;
      letter-spacing:.2px;
    }

    input[type="text"]{
      width: 100%;
      box-sizing:border-box;
      background: rgba(0,0,0,.18);
      border: 1px solid rgba(255,255,255,.16);
      border-radius: 10px;
      padding: 8px 10px;
      font-weight: 800;
    }

    select{
      width: 100%;
      background: rgba(0,0,0,.18);
      border: 1px solid rgba(255,255,255,.16);
      border-radius: 10px;
      padding: 8px 10px;
      font-weight: 800;
    }

    #miniMenu{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      justify-content:flex-start;
      align-content:flex-start;
    }

    .miniBtn{
      width: 72px;
      height: 72px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.16);
      background: rgba(0,0,0,.16);
      position:relative;
      cursor:pointer;
      user-select:none;
      display:flex;
      align-items:flex-end;
      justify-content:flex-end;
      padding:6px;
      box-sizing:border-box;
    }
    .miniBtn.selected{
      outline: 3px solid rgba(255,255,255,.82);
      outline-offset: 2px;
      background: rgba(255,255,255,.06);
    }
    .miniId{
      font-size: 12px;
      font-weight: 1000;
      opacity:.9;
      text-shadow: 0 2px 10px rgba(0,0,0,.45);
    }
    .miniSvg{
      position:absolute;
      inset:6px;
      pointer-events:none;
    }

    textarea{
      width:100%;
      box-sizing:border-box;
      min-height: 150px;
      resize: vertical;
      background: rgba(0,0,0,.18);
      border: 1px solid rgba(255,255,255,.16);
      border-radius: 10px;
      padding: 8px 10px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      font-size: 12px;
      line-height: 1.35;
    }

    #status{
      min-height: 18px;
      font-weight:900;
      user-select:none;
      text-align:center;
      opacity:.92;
    }
    #status.ok{ color: var(--good); }
    #status.bad{ color: var(--bad); }
    #status.warn{ color: var(--warn); }

    
    /* SOLVER MODAL */
    .modal{
      position:fixed; inset:0; display:none;
      align-items:center; justify-content:center;
      background:rgba(0,0,0,.55); z-index:9999;
    }
    .modal.open{ display:flex; }
    .modalCard{
      width:min(720px,96vw); max-height:80vh; overflow:auto;
      background:#0b1533; border-radius:16px;
      border:1px solid rgba(255,255,255,.2);
      padding:14px;
    }
    .modalHead{ display:flex; justify-content:space-between; align-items:center; }
    .modalTitle{ font-weight:900; }
    .modalMeta{ font-size:12px; margin:8px 0; }
    .solveList{ display:flex; flex-direction:column; gap:8px; }
    .solveRow{ display:flex; align-items:center; gap:10px;
      padding:8px; border-radius:10px;
      background:rgba(255,255,255,.08); }
    .solveNum{ width:32px; text-align:right; font-weight:900; }
    .solveBall{ width:14px; height:14px; border-radius:50%;
      border:2px solid #fff; }
    .solveArrow{ font-size:18px; font-weight:900; }

    @media (max-width: 900px){
      main{ grid-template-columns: 1fr; grid-template-rows: auto auto; }
    }
  </style>
</head>

<body>
<div id="app">
  <header>
    <h1>Anti-Virus <span class="sub">builder</span></h1>
    <div class="btnbar">
      <button id="btnNew">Uusi</button>
      <button id="btnDup">Kopioi</button>
      <button id="btnDel">Poista</button>
      <button id="btnClear">Tyhjennä</button>
      <button id="btnSolve">Solve</button>
    </div>
  </header>

  <main>
    <div id="boardWrap">
      <div id="board">
        <div id="exitTag">EXIT: A1</div>
        <div id="grid"></div>
        <div id="blocksLayer"></div>
        <div id="piecesLayer"></div>
      </div>
    </div>

    <div id="side">
      <div class="card">
        <div class="label">Pulmat</div>
        <div style="height:6px"></div>
        <select id="puzzleSelect"></select>
        <div style="height:8px"></div>
        <input id="puzzleName" type="text" placeholder="Pulman nimi">
        <div style="height:8px"></div>
        <div class="row">
          <button id="btnPrev">◀</button>
          <button id="btnNext">▶</button>
          <button id="btnSave">Tallenna</button>
        </div>
      </div>

      <div class="card">
        <div class="label">Palat (1. klikkaus valitsee, seuraavat kiertää rot)</div>
        <div style="height:8px"></div>
        <div id="miniMenu"></div>
        <div style="height:10px"></div>
        <div style="font-size:12px;opacity:.9;line-height:1.35;">
          Valittu: <b id="selInfo">—</b><br>
          Laudalle klikkaus: aseta valittu pala (tai Este).<br>
          Palan ympyrää klikkaus: poista pala. Esteen klikkaus: poista este.
        </div>
      </div>

      <div class="card">
        <div class="label">Export / Import</div>
        <div style="height:8px"></div>
        <div class="row">
          <button id="btnExport">Export</button>
          <button id="btnImport">Import</button>
        </div>
        <div style="height:8px"></div>
        <textarea id="io"></textarea>
      </div>

      <div id="status"></div>
    </div>
  </main>

  <!-- Solver result modal -->
  <div id="solveModal" class="modal" aria-hidden="true">
    <div class="modalCard">
      <div class="modalHead">
        <div class="modalTitle">Ratkaisu</div>
        <button id="btnSolveClose" class="modalClose">✕</button>
      </div>
      <div id="solveMeta" class="modalMeta"></div>
      <div id="solveList" class="solveList"></div>
    </div>
  </div>

</div>

<script>
/* ======================
   BOARD RULES (0..7)
   ====================== */
const W=8, H=8;
function onBoard(x,y){ return x>=0 && x<W && y>=0 && y<H; }
function isWhite(x,y){ return ((x+y)&1)===0; } // A1 (0,0) valkea
function isPlayable(x,y){
  if (!onBoard(x,y)) return false;
  if (x===0 && y===0) return true; // EXIT
  if (y===0) return false;         // rivi 1 pois
  if (x===0) return false;         // sarake A pois
  return isWhite(x,y);
}
function key(x,y){ return `${x},${y}`; }

/* ======================
   PIECE DEFS (your spec)
   ====================== */
const PIECE_DEFS = {
  // diagonaalidomino (aina diagonaali kaikissa rotaatioissa)
  0: { id:0, name:"Punainen",     color:"#ff3b3b", shape:[[0,0],[1,1]] },
  1: { id:1, name:"Vaaleansin.",  color:"#4ecbff", shape:[[0,0],[1,1]] },

  // oranssi: 3 ruutua, kaikki valkeilla (dx+dy parillinen)
  // (tämä vastaa alkuperäistä "V"-ideaa, mutta board-deltana)
  2: { id:2, name:"Oranssi",      color:"#ff9f1c", shape:[[0,0],[1,1],[0,2]] },

  3: { id:3, name:"Pinkki",       color:"#ff7abf", shape:[[0,0],[0,2]] },
  4: { id:4, name:"Tummanvihreä", color:"#2ecc71", shape:[[0,0],[0,2]] },

  5: { id:5, name:"Tummansininen",color:"#1f5fbf", shape:[[0,0],[2,0],[4,0]] },

  6: { id:6, name:"Violetti",     color:"#b06cff", shape:[[0,0],[2,0],[2,2]] },

  // lime toimii jo
  7: { id:7, name:"Lime",         color:"#b7e600", shape:[[0,0],[1,1],[1,3]] },

  // keltainen = peilikuva limestä (dx -> -dx)
  8: { id:8, name:"Keltainen",    color:"#ffd400", shape:[[0,0],[-1,1],[-1,3]] },
};


const TOOL_BLOCK = "block";

/* ======================
   ROTATION
   rot=0..3, 90° CCW steps
   ====================== */

/* 90° CCW in board delta coords:
   (dx,dy) -> (-dy, dx)
*/
function rotPtCCW(dx, dy, steps){
  const r = ((steps%4)+4)%4;
  if (r===0) return [dx, dy];
  if (r===1) return [-dy, dx];
  if (r===2) return [-dx, -dy];
  if (r===3) return [dy, -dx];
  return [dx, dy];
}

/* ✅ For MINIs only: rotate + normalize (nice in a box) */
function rotatedNormalized(points, rotSteps){
  const rp = points.map(([dx,dy]) => rotPtCCW(dx,dy,rotSteps));
  let minX=Infinity, minY=Infinity;
  for (const [x,y] of rp){ minX=Math.min(minX,x); minY=Math.min(minY,y); }
  return rp.map(([x,y]) => [x-minX, y-minY]);
}

/* ✅ For BOARD: rotate only, DO NOT normalize (anchor must not jump) */
function rotatedPointsNoNorm(points, rotSteps){
  return points.map(([dx,dy]) => rotPtCCW(dx,dy,rotSteps));
}

/* Board cells covered by a piece at anchor (x0,y0) */
function pieceCells(piece){
  const def = PIECE_DEFS[piece.id];
  const pts = rotatedPointsNoNorm(def.shape, piece.rot|0); // <-- CRITICAL
  return pts.map(([dx,dy]) => ({ x: piece.x0 + dx, y: piece.y0 + dy }));
}

/* ======================
   UI refs
   ====================== */
const elGrid = document.getElementById("grid");
const elBlocks = document.getElementById("blocksLayer");
const elPieces = document.getElementById("piecesLayer");
const elMini = document.getElementById("miniMenu");
const elSelInfo = document.getElementById("selInfo");
const elStatus = document.getElementById("status");

const elPuzzleSelect = document.getElementById("puzzleSelect");
const elPuzzleName = document.getElementById("puzzleName");

const btnNew = document.getElementById("btnNew");
const btnDup = document.getElementById("btnDup");
const btnDel = document.getElementById("btnDel");
const btnClear = document.getElementById("btnClear");
const btnPrev = document.getElementById("btnPrev");
const btnNext = document.getElementById("btnNext");
const btnSave = document.getElementById("btnSave");

const btnExport = document.getElementById("btnExport");
const btnImport = document.getElementById("btnImport");
const elIO = document.getElementById("io");

/* ======================
   STATE
   ====================== */
const LS_KEY = "antivirus_builder_v1";

let puzzles = [];
let current = 0;

let palette = {
  selected: null,      // number id or "block"
  rotById: {}          // id -> rot 0..3
};

/* ======================
   Status helper
   ====================== */
function setStatus(msg, cls=""){
  elStatus.textContent = msg || "";
  elStatus.className = cls || "";
}

/* ======================
   Layout sizing
   ====================== */
function rebuildCellSize(){
  const wrap = document.getElementById("boardWrap").getBoundingClientRect();
  const avail = Math.min(wrap.width, wrap.height);
  const gap = 8;
  const pad = 10;
  const cell = Math.floor((avail - (gap*7) - (pad*2) - 4) / 8);
  const clamped = Math.max(34, Math.min(74, cell));
  document.documentElement.style.setProperty("--cell", clamped + "px");
  document.documentElement.style.setProperty("--gap", gap + "px");
  document.documentElement.style.setProperty("--boardPad", pad + "px");
}
window.addEventListener("resize", rebuildCellSize);

/* offset for scaled dots */
function dotOffset(cell){
  const scale = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--dotScale"));
  return -((scale - 1) / 2) * cell;
}

/* ======================
   Build board grid
   ====================== */
function buildGrid(){
  elGrid.innerHTML = "";
  for (let y=0; y<H; y++){
    for (let x=0; x<W; x++){
      const d = document.createElement("div");
      d.className = "cell";
      const off = ((y===0 || x===0) && !(x===0 && y===0));
      if (off) d.classList.add("off");
      if (isPlayable(x,y)) d.classList.add("playable");
      if (x===0 && y===0) d.classList.add("exit");

      d.dataset.x = String(x);
      d.dataset.y = String(y);

      d.addEventListener("pointerdown", (ev)=>{
        ev.preventDefault();
        if (!isPlayable(x,y)) return;
        onBoardClick(x,y);
      });

      elGrid.appendChild(d);
    }
  }
}

/* ======================
   Puzzle data helpers
   ====================== */
function ensureDefaultPuzzles(){
  if (puzzles.length) return;
  puzzles = [{
    name: "Pulma 1",
    blocks: [{x:6,y:6}],
    pieces: [
      { id:0, x0:4, y0:4, rot:1 },
      { id:6, x0:3, y0:3, rot:3 }
    ]
  }];
  current = 0;
}
function currentPuzzle(){ return puzzles[current]; }

function saveToLS(silent=false){
  try{
    localStorage.setItem(LS_KEY, JSON.stringify({puzzles, current}));
    if (!silent) setStatus("Tallennettu.", "ok");
  }catch(e){
    setStatus("Tallennus epäonnistui (localStorage).", "bad");
  }
}

function loadFromLS(){
  try{
    const raw = localStorage.getItem(LS_KEY);
    if (!raw) return false;
    const obj = JSON.parse(raw);
    if (!obj || !Array.isArray(obj.puzzles)) return false;
    puzzles = obj.puzzles;
    current = Math.max(0, Math.min(obj.current|0, puzzles.length-1));
    return true;
  }catch(e){
    return false;
  }
}

/* ======================
   Render puzzles list
   ====================== */
function renderPuzzleSelect(){
  elPuzzleSelect.innerHTML = "";
  puzzles.forEach((p, i)=>{
    const opt = document.createElement("option");
    opt.value = String(i);
    opt.textContent = `${i+1}. ${p.name || "(nimetön)"}`;
    elPuzzleSelect.appendChild(opt);
  });
  elPuzzleSelect.value = String(current);
  elPuzzleName.value = currentPuzzle().name || "";
}

elPuzzleSelect.addEventListener("change", ()=>{
  const idx = parseInt(elPuzzleSelect.value, 10);
  if (!Number.isFinite(idx)) return;
  current = idx;
  renderPuzzleSelect();
  renderAll();
  saveToLS(true);
});

elPuzzleName.addEventListener("input", ()=>{
  currentPuzzle().name = elPuzzleName.value;
  renderPuzzleSelect();
});

/* ======================
   Mini menu
   ====================== */
function makeMiniSVG(def, rot){
  const pts = rotatedNormalized(def.shape, rot); // <- keep as it was (visual only)

  let maxX=0, maxY=0;
  for (const [x,y] of pts){ maxX=Math.max(maxX,x); maxY=Math.max(maxY,y); }

  const unit = 12;
  const svgW = 60, svgH = 60;
  const contentW = (maxX+1)*unit;
  const contentH = (maxY+1)*unit;
  const ox = (svgW - contentW)/2 + unit*0.5;
  const oy = (svgH - contentH)/2 + unit*0.5;

  const circles = pts.map(([x,y])=>{
    const cx = ox + x*unit;
    const cy = oy + y*unit;
    return `<circle cx="${cx}" cy="${cy}" r="9.5" fill="${def.color}" stroke="rgba(255,255,255,.45)" stroke-width="2"/>`;
  }).join("");

  return `
    <svg class="miniSvg" viewBox="0 0 60 60" width="60" height="60" aria-hidden="true">
      ${circles}
    </svg>
  `;
}

function renderMiniMenu(){
  elMini.innerHTML = "";

  Object.keys(PIECE_DEFS).map(n=>parseInt(n,10)).sort((a,b)=>a-b).forEach((id)=>{
    const def = PIECE_DEFS[id];
    const rot = palette.rotById[id] ?? 0;

    const b = document.createElement("div");
    b.className = "miniBtn" + (palette.selected===id ? " selected" : "");
    b.innerHTML = makeMiniSVG(def, rot) + `<div class="miniId">${id}</div>`;

    b.addEventListener("pointerdown", (ev)=>{
      ev.preventDefault();
      onMiniClick(id);
    });

    elMini.appendChild(b);
  });

  // block tool
  const bb = document.createElement("div");
  bb.className = "miniBtn" + (palette.selected===TOOL_BLOCK ? " selected" : "");
  bb.innerHTML = `
    <svg class="miniSvg" viewBox="0 0 60 60" width="60" height="60" aria-hidden="true">
      <circle cx="30" cy="30" r="14" fill="rgba(255,255,255,.92)" stroke="rgba(0,0,0,.18)" stroke-width="2"/>
    </svg>
    <div class="miniId">Este</div>
  `;
  bb.addEventListener("pointerdown",(ev)=>{
    ev.preventDefault();
    onMiniClick(TOOL_BLOCK);
  });
  elMini.appendChild(bb);

  updateSelInfo();
}

function updateSelInfo(){
  if (palette.selected===null){
    elSelInfo.textContent = "—";
    return;
  }
  if (palette.selected===TOOL_BLOCK){
    elSelInfo.textContent = "Este";
    return;
  }
  const id = palette.selected;
  const rot = palette.rotById[id] ?? 0;
  const def = PIECE_DEFS[id];
  elSelInfo.textContent = `${id} (${def.name}) rot=${rot}`;
}

function onMiniClick(idOrTool){
  if (palette.selected === idOrTool){
    if (typeof idOrTool === "number"){
      const cur = palette.rotById[idOrTool] ?? 0;
      palette.rotById[idOrTool] = (cur + 1) % 4;
    }
  }else{
    palette.selected = idOrTool;
  }
  renderMiniMenu();
  setStatus("", "");
}

/* ======================
   Validations
   ====================== */
function buildOccMap(puz, exceptPieceId=null){
  const occ = new Map();

  // walls = all non-playable
  for (let y=0; y<H; y++){
    for (let x=0; x<W; x++){
      if (!isPlayable(x,y)) occ.set(key(x,y), "#");
    }
  }

  // blocks
  for (const b of puz.blocks){
    occ.set(key(b.x,b.y), "B");
  }

  // pieces
  for (const pc of puz.pieces){
    if (exceptPieceId!==null && pc.id===exceptPieceId) continue;
    const cells = pieceCells(pc);
    for (const c of cells){
      occ.set(key(c.x,c.y), pc.id);
    }
  }

  return occ;
}

function canPlacePiece(puz, piece){
  const occ = buildOccMap(puz, piece.id);

  const cells = pieceCells(piece);
  for (const c of cells){
    if (!onBoard(c.x,c.y)) return {ok:false, msg:"Reuna estää."};
    if (!isPlayable(c.x,c.y)) return {ok:false, msg:"Ei pelialuetta."};
    if (occ.has(key(c.x,c.y))) return {ok:false, msg:"Päällekkäisyys / este."};
  }
  return {ok:true};
}

/* ======================
   Board interactions
   ====================== */
function onBoardClick(x,y){
  const puz = currentPuzzle();

  /* ===== ESTE-työkalu ===== */
  if (palette.selected === TOOL_BLOCK){
    const k = key(x,y);
    const idx = puz.blocks.findIndex(b => key(b.x,b.y)===k);
    if (idx>=0){
      puz.blocks.splice(idx,1);
      setStatus("Este poistettu.", "ok");
    }else{
      const occ = buildOccMap(puz, null);
      if (occ.has(k)){
        setStatus("Ei voi asettaa esteen päälle.", "bad");
        return;
      }
      puz.blocks.push({x,y});
      setStatus("Este asetettu.", "ok");
    }
    renderAll();
    saveToLS(true);
    return;
  }

  /* ===== PALAT ===== */
  if (palette.selected === null || typeof palette.selected !== "number"){
    setStatus("Valitse pala tai Este.", "warn");
    return;
  }

  const id  = palette.selected;
  const rot = palette.rotById[id] ?? 0;

  // kerätään mahdolliset ankkurit:
  // ensin klikattu, sitten pienet siirrot ympäriltä
  const candidates = [];
  candidates.push({x0:x, y0:y});

  for (let dy=-2; dy<=2; dy++){
    for (let dx=-2; dx<=2; dx++){
      if (dx===0 && dy===0) continue;
      candidates.push({x0:x+dx, y0:y+dy});
    }
  }

  let placed = null;
  let lastErr = "Ei mahdu.";

  for (const c of candidates){
    const piece = { id, x0:c.x0, y0:c.y0, rot };
    const res = canPlacePiece(puz, piece);
    if (res.ok){
      placed = piece;
      break;
    }else{
      lastErr = res.msg;
    }
  }

  if (!placed){
    setStatus(lastErr, "bad");
    return;
  }

  // jos pala on jo laudalla, siirretään sitä
  const ex = puz.pieces.findIndex(p=>p.id===id);
  if (ex>=0) puz.pieces.splice(ex,1);
  puz.pieces.push(placed);

  setStatus(`Pala ${id} asetettu.`, "ok");
  renderAll();
  saveToLS(true);
}


function removePieceById(id){
  const puz = currentPuzzle();
  const idx = puz.pieces.findIndex(p=>p.id===id);
  if (idx>=0){
    puz.pieces.splice(idx,1);
    setStatus(`Pala ${id} poistettu.`, "ok");
    renderAll();
    saveToLS(true);
  }
}

function toggleBlockAt(x,y){
  const puz = currentPuzzle();
  const k = key(x,y);
  const idx = puz.blocks.findIndex(b => key(b.x,b.y)===k);
  if (idx>=0){
    puz.blocks.splice(idx,1);
    setStatus("Este poistettu.", "ok");
    renderAll();
    saveToLS(true);
  }
}

/* ======================
   Render board layers
   ====================== */
function renderBlocks(){
  elBlocks.innerHTML = "";

  const cell = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--cell"));
  const gap  = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--gap"));
  const pad  = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--boardPad"));
  const off  = dotOffset(cell);

  function xyToPx(x,y){
    return {
      left: pad + x*(cell+gap) + off,
      top:  pad + y*(cell+gap) + off
    };
  }

  const puz = currentPuzzle();
  for (const b of puz.blocks){
    const pos = xyToPx(b.x,b.y);
    const d = document.createElement("div");
    d.className = "dot blockDot";
    d.style.left = pos.left + "px";
    d.style.top = pos.top + "px";
    d.style.background = "rgba(255,255,255,.92)";
    d.addEventListener("pointerdown",(ev)=>{
      ev.preventDefault();
      toggleBlockAt(b.x,b.y);
    });
    elBlocks.appendChild(d);
  }
}

function renderPieces(){
  elPieces.innerHTML = "";

  const cell = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--cell"));
  const gap  = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--gap"));
  const pad  = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--boardPad"));
  const off  = dotOffset(cell);

  function xyToPx(x,y){
    return {
      left: pad + x*(cell+gap) + off,
      top:  pad + y*(cell+gap) + off
    };
  }

  const puz = currentPuzzle();
  for (const pc of puz.pieces){
    const def = PIECE_DEFS[pc.id];
    const cells = pieceCells(pc);

    for (const c of cells){
      const pos = xyToPx(c.x,c.y);
      const d = document.createElement("div");
      d.className = "dot pieceDot";
      d.style.left = pos.left + "px";
      d.style.top = pos.top + "px";
      d.style.background = def.color;
      d.dataset.piece = String(pc.id);

      d.addEventListener("pointerdown",(ev)=>{
        ev.preventDefault();
        const pid = parseInt(d.dataset.piece,10);
        removePieceById(pid);
      });

      elPieces.appendChild(d);
    }
  }
}

function renderAll(){
  renderBlocks();
  renderPieces();
}

/* ======================
   Puzzle CRUD
   ====================== */
function newPuzzle(){
  puzzles.push({ name:`Pulma ${puzzles.length+1}`, blocks:[], pieces:[] });
  current = puzzles.length-1;
  renderPuzzleSelect();
  renderAll();
  saveToLS(true);
  setStatus("Uusi pulma luotu.", "ok");
}

function dupPuzzle(){
  const src = currentPuzzle();
  const copy = {
    name: (src.name || "Pulma") + " (kopio)",
    blocks: src.blocks.map(b=>({x:b.x,y:b.y})),
    pieces: src.pieces.map(p=>({id:p.id,x0:p.x0,y0:p.y0,rot:p.rot}))
  };
  puzzles.push(copy);
  current = puzzles.length-1;
  renderPuzzleSelect();
  renderAll();
  saveToLS(true);
  setStatus("Kopioitu.", "ok");
}

function delPuzzle(){
  if (puzzles.length<=1){
    setStatus("Viimeistä pulmaa ei poisteta.", "warn");
    return;
  }
  puzzles.splice(current,1);
  current = Math.max(0, Math.min(current, puzzles.length-1));
  renderPuzzleSelect();
  renderAll();
  saveToLS(true);
  setStatus("Poistettu.", "ok");
}

function clearPuzzle(){
  const p = currentPuzzle();
  p.blocks = [];
  p.pieces = [];
  renderAll();
  saveToLS(true);
  setStatus("Pulma tyhjennetty.", "ok");
}

/* ======================
   Buttons
   ====================== */
btnNew.addEventListener("click", newPuzzle);
btnDup.addEventListener("click", dupPuzzle);
btnDel.addEventListener("click", delPuzzle);
btnClear.addEventListener("click", clearPuzzle);

btnPrev.addEventListener("click", ()=>{
  current = (current-1 + puzzles.length) % puzzles.length;
  renderPuzzleSelect();
  renderAll();
  saveToLS(true);
});

btnNext.addEventListener("click", ()=>{
  current = (current+1) % puzzles.length;
  renderPuzzleSelect();
  renderAll();
  saveToLS(true);
});

btnSave.addEventListener("click", ()=>{
  currentPuzzle().name = elPuzzleName.value;
  renderPuzzleSelect();
  saveToLS(true);
  setStatus("Tallennettu.", "ok");
});

/* ======================
   Export / Import
   ====================== */
btnExport.addEventListener("click", ()=>{
  const payload = { puzzles, current };
  elIO.value = JSON.stringify(payload, null, 2);
  setStatus("Export valmis.", "ok");
});

btnImport.addEventListener("click", ()=>{
  try{
    const obj = JSON.parse(elIO.value);
    if (!obj || !Array.isArray(obj.puzzles)) throw new Error("Virheellinen JSON.");
    puzzles = obj.puzzles;
    current = Math.max(0, Math.min(obj.current|0, puzzles.length-1));
    if (puzzles.length===0) throw new Error("Ei pulmia.");
    renderPuzzleSelect();
    renderAll();
    saveToLS(true);
    setStatus("Import ok.", "ok");
  }catch(e){
    setStatus("Import epäonnistui: " + (e?.message || "virhe"), "bad");
  }
});


/* ======================
   SOLVER (Anti-Virus correct rules)
   - Can slide THROUGH dark cells
   - May STOP only on playable cells
   ====================== */

const DIRS = [
  {dx:  1, dy:  1, arrow:"↘"},
  {dx:  1, dy: -1, arrow:"↗"},
  {dx: -1, dy:  1, arrow:"↙"},
  {dx: -1, dy: -1, arrow:"↖"},
];

function clonePieces(pieces){
  return pieces.map(p=>({ id:p.id, x0:p.x0, y0:p.y0, rot:p.rot|0 }));
}

function normalizePieces(pieces){
  return clonePieces(pieces).sort((a,b)=>a.id-b.id);
}

function hashState(pieces){
  return normalizePieces(pieces)
    .map(p=>`${p.id}:${p.x0},${p.y0},${p.rot}`)
    .join("|");
}

function occMapForSolver(puz, pieces, exceptId=null){
  const occ = new Map();
  for (const b of puz.blocks){
    occ.set(key(b.x,b.y), "B");
  }
  for (const p of pieces){
    if (p.id===exceptId) continue;
    for (const c of pieceCells(p)){
      occ.set(key(c.x,c.y), p.id);
    }
  }
  return occ;
}

function canPassThrough(puz, pieces, piece){
  const occ = occMapForSolver(puz, pieces, piece.id);
  for (const c of pieceCells(piece)){
    if (!onBoard(c.x,c.y)) return false;
    if (!isPlayable(c.x,c.y)) return false; // pieces must always occupy playable cells
    if (occ.has(key(c.x,c.y))) return false;
  }
  return true;
}

function genMovesForPieceSolver(puz, pieces, piece){
  const out = [];
  const occ = occMapForSolver(puz, pieces, piece.id);

  for (const dir of DIRS){
    let step = 1;
    while (true){
      const cand = { id:piece.id, rot:piece.rot, x0: piece.x0 + dir.dx*step, y0: piece.y0 + dir.dy*step };

      let ok = true;
      for (const c of pieceCells(cand)){
        if (!onBoard(c.x,c.y) || !isPlayable(c.x,c.y)) { ok=false; break; }
        if (occ.has(key(c.x,c.y))) { ok=false; break; }
      }
      if (!ok) break;

      out.push({ moved: cand, move: { id: piece.id, arrow: dir.arrow } });
      step++;
    }
  }
  return out;
}

function isWinSolver(pieces){
  const red = pieces.find(p=>p.id===0);
  if (!red) return false;
  return pieceCells(red).some(c=>c.x===0 && c.y===0);
}

function solvePuzzle(puz, opts={}){
  const maxNodes = opts.maxNodes ?? 600000;
  const maxDepth = opts.maxDepth ?? 120;

  const startPieces = normalizePieces(puz.pieces||[]);
  if (!startPieces.some(p=>p.id===0)) return null;

  const startHash = hashState(startPieces);
  const queue = [startPieces];
  const qHash = [startHash];
  const parent = new Map();
  const depth = new Map();

  parent.set(startHash, null);
  depth.set(startHash, 0);

  let qi = 0, explored = 0;

  if (isWinSolver(startPieces)){
    return { ok:true, moves:[], explored:0 };
  }

  while (qi < queue.length){
    const pieces = queue[qi];
    const h = qHash[qi];
    qi++; explored++;

    const d = depth.get(h);
    if (d>=maxDepth || explored>maxNodes) continue;

    for (const p of pieces){
      const moves = genMovesForPieceSolver(puz, pieces, p);
      for (const mm of moves){
        const moved = mm.moved;

        const next = clonePieces(pieces);
        const idx = next.findIndex(pp=>pp.id===p.id);
        next[idx] = moved;

        const norm = normalizePieces(next);
        const nh = hashState(norm);
        if (parent.has(nh)) continue;

        parent.set(nh, { prev:h, move: mm.move });
        depth.set(nh, d+1);

        if (isWinSolver(norm)){
          const path = [];
          let cur = nh;
          while (cur!==startHash){
            const rec = parent.get(cur);
            path.push(rec.move);
            cur = rec.prev;
          }
          path.reverse();
          return { ok:true, moves:path, explored };
        }

        queue.push(norm);
        qHash.push(nh);
      }
    }
  }
  return { ok:false, explored };
}


/* ======================
   Solver UI
   ====================== */
const btnSolve = document.getElementById("btnSolve");
const elSolveModal = document.getElementById("solveModal");
const btnSolveClose = document.getElementById("btnSolveClose");
const elSolveMeta = document.getElementById("solveMeta");
const elSolveList = document.getElementById("solveList");

function openSolveModal(){
  elSolveModal.classList.add("open");
}
function closeSolveModal(){
  elSolveModal.classList.remove("open");
}
btnSolveClose.addEventListener("click", closeSolveModal);
elSolveModal.addEventListener("pointerdown",(e)=>{
  if (e.target===elSolveModal) closeSolveModal();
});

btnSolve.addEventListener("click", ()=>{
  const puz = currentPuzzle();
  setStatus("Solveri hakee ratkaisua…","warn");

  setTimeout(()=>{
    const res = solvePuzzle(puz);
    elSolveList.innerHTML = "";

    if (res && res.ok){
      elSolveMeta.textContent = `Ratkaistavissa • siirtoja ${res.moves.length}`;
      res.moves.forEach((m,i)=>{
        const row = document.createElement("div");
        row.className = "solveRow";
        const n = document.createElement("div");
        n.className = "solveNum";
        n.textContent = (i+1)+".";
        const ball = document.createElement("div");
        ball.className = "solveBall";
        ball.style.background = PIECE_DEFS[m.id].color;
        const arrow = document.createElement("div");
        arrow.className = "solveArrow";
        arrow.textContent = m.arrow;
        row.append(n, ball, arrow);
        elSolveList.appendChild(row);
      });
      setStatus("Ratkaisu löytyi.","ok");
    }else{
      elSolveMeta.textContent = "Ei ratkaisua.";
      setStatus("Ei ratkaisua.","bad");
    }
    openSolveModal();
  },20);
});

/* ======================
   Init
   ====================== */
rebuildCellSize();
buildGrid();

const loaded = loadFromLS();
if (!loaded) ensureDefaultPuzzles();

renderPuzzleSelect();

// default selection
palette.selected = 0;
palette.rotById[0] = palette.rotById[0] ?? 0;

renderMiniMenu();
renderAll();

setStatus("Valitse pala ja klikkaa pelilautaa.", "warn");
</script>
</body>
</html>
